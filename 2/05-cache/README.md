# Cache

Cached API data and frequently accessed information. All contents are **gitignored**.

## Purpose

This folder stores cached data from external APIs to:
- Reduce redundant API calls
- Improve Claude Code response time
- Provide offline fallback data
- Store frequently accessed metadata

## Common Cache Files

### Ticket System Cache
- **[ticket-system]-transitions.json** - Available ticket status transitions
- **[ticket-system]-issue-types.json** - Issue type metadata
- **[ticket-system]-fields.json** - Custom field definitions
- **[ticket-system]-projects.json** - Project list and metadata

### Configuration Cache
- **team-members.json** - Team member list (for assignments)
- **labels.json** - Available labels/tags
- **priorities.json** - Priority levels
- **components.json** - Component list

### API Metadata
- **api-schemas.json** - OpenAPI/GraphQL schemas
- **endpoints.json** - Available API endpoints
- **rate-limits.json** - API rate limit information

## Cache File Format

Use JSON for machine-readability:

```json
{
  "cached_at": "2024-11-28T10:00:00Z",
  "ttl_seconds": 3600,
  "source": "API_NAME",
  "data": {
    "key": "value"
  }
}
```

### Required Fields
- `cached_at`: ISO 8601 timestamp
- `ttl_seconds`: Time-to-live in seconds (or null for no expiration)
- `source`: Where data came from
- `data`: The actual cached data

## Cache Management

### Regeneration
Cache files should be regenerated by:
- Initialization script (e.g., `./run.sh init`)
- Claude Code (when cache is missing/stale)
- Scheduled job (for frequently changing data)

### Expiration
- Check `cached_at` + `ttl_seconds` to determine if stale
- If stale, regenerate automatically
- If API call fails, use stale cache as fallback

### Gitignore
**All files in this folder should be gitignored**

Add to `.gitignore`:
```
memory-bank/05-cache/**
!memory-bank/05-cache/README.md
```

## Usage Pattern

```
1. Claude needs ticket transitions
2. Check: Does 05-cache/jira-transitions.json exist?
3. Check: Is it stale? (cached_at + ttl < now)
4. If missing or stale:
   - Call API
   - Save to cache
   - Use data
5. If fresh:
   - Load from cache
   - Use data
```

## Example: Ticket Transitions Cache

```json
{
  "cached_at": "2024-11-28T10:00:00Z",
  "ttl_seconds": 86400,
  "source": "Jira Cloud API",
  "data": {
    "transitions": [
      {
        "id": "11",
        "name": "To Do",
        "to": {
          "id": "10000",
          "name": "To Do"
        }
      },
      {
        "id": "21",
        "name": "In Progress",
        "to": {
          "id": "10001",
          "name": "In Progress"
        }
      }
    ]
  }
}
```

## Customization Guide

### Step 1: Identify Cacheable Data
List APIs/data that are:
- Frequently accessed
- Slow to fetch
- Rarely change
- Available via API

### Step 2: Create Cache Scripts
Write scripts to populate cache:
- `scripts/cache-init.sh` - Initialize all caches
- `scripts/cache-[name].sh` - Cache specific data

### Step 3: Configure TTL
Set appropriate TTL for each cache type:
- **High frequency changes** (user status): 300s (5 min)
- **Medium frequency** (ticket metadata): 3600s (1 hour)
- **Low frequency** (project list): 86400s (1 day)
- **Static** (API schemas): null (never expire)

### Step 4: Document Cache Schema
For each cache file, document:
- What data it contains
- How to regenerate it
- When it's used
- Expected format

## Troubleshooting

### Cache is stale
**Solution**: Delete cache file, let Claude regenerate

### Cache is corrupt
**Solution**: Delete cache file, regenerate from API

### API rate limited
**Solution**:
1. Increase TTL to reduce API calls
2. Use stale cache as fallback
3. Implement exponential backoff

### Cache taking too much space
**Solution**:
1. Reduce TTL for large caches
2. Add cleanup script for old caches
3. Compress cache files (gzip)

## Maintenance

### Regular Cleanup
```bash
# Remove caches older than 7 days
find memory-bank/05-cache -type f -name "*.json" -mtime +7 -delete

# Keep only README
find memory-bank/05-cache -type f ! -name "README.md" -delete
```

### Cache Validation
Periodically verify cache accuracy:
1. Fetch fresh data from API
2. Compare with cached data
3. If mismatch, invalidate cache

## Security Notes

- **Never cache sensitive data** (passwords, tokens, PII)
- **Gitignore all cache files** to prevent accidental commits
- **Sanitize data** before caching (remove sensitive fields)
- **Use cache for metadata only**, not business data

---

**Customize this folder** by identifying and caching frequently accessed API data specific to your project.